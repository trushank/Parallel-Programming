import java.io.File;
import java.util.ArrayList;
import java.util.Scanner;

import edu.rit.pj2.Job;
import edu.rit.pj2.LongVbl;
import edu.rit.pj2.Loop;
import edu.rit.pj2.Node;
import edu.rit.pj2.Rule;
import edu.rit.pj2.Task;
import edu.rit.pj2.TaskSpec;
import edu.rit.pj2.Tuple;
import edu.rit.util.LongRange;

// TODO: Auto-generated Javadoc
/**
 * The Class MaxCliqueClu.
 */
public class MaxCliqueClu extends Job {

	/*
	 * (non-Javadoc)
	 * 
	 * @see edu.rit.pj2.Job#main(java.lang.String[])
	 */
	@Override
	public void main(String[] arg0) throws Exception {
		int K = Integer.parseInt(arg0[0]);
		int CF = 20;
		Scanner fileIn = new Scanner(new File("graph.txt"));
		ArrayList<Long> tempList = new ArrayList<Long>();
		long[] graph;
		while (fileIn.hasNextLong()) {
			tempList.add(fileIn.nextLong());
		}
		graph = new long[tempList.size()];
		for (int i = 0; i < tempList.size(); i++) {
			graph[i] = tempList.get(i);
		}

		long full = (1L << graph.length) - 1L;
		// Set up a task group of K worker tasks.
		rule(new Rule().task(K, new TaskSpec(WorkerTask.class)
				.requires(new Node().cores(Node.ALL_CORES))));

		// Set up reduction task.
		rule(new Rule().atFinish().task(
				new TaskSpec(ReduceTask.class).runInJobProcess(true)));

		// Partition the iterations into chunks for the worker tasks.
		for (LongRange chunk : new LongRange(0, full).subranges(K * CF))
			putTuple(new ChunkTuple(chunk));

		// putting K input arrays into tuplespace
		for (int i = 0; i < K; i++) {
			putTuple(new InputTuple(graph, full));
		}

	}

	/**
	 * The Class WorkerTask.
	 * 
	 * @author Trushank
	 */
	public static class WorkerTask extends Task {

		/*
		 * (non-Javadoc)
		 * 
		 * @see edu.rit.pj2.Task#main(java.lang.String[])
		 */
		@Override
		public void main(String[] arg0) throws Exception {

			// Compute chunks of iterations.
			ChunkTuple template = new ChunkTuple();
			ChunkTuple chunk;
			final long[] graph;
			final long full;
			
			InputTuple inp = (InputTuple) takeTuple(new InputTuple());
			graph = inp.graph;
			full = inp.full;
			long finalCount = 0;
			long finalClique=0;

			while ((chunk = (ChunkTuple) tryToTakeTuple(template)) != null) {
				final LongVbl maxSize = new LongVbl.Max(); // final result
				final LongVbl clique = new LongVbl.Max();
				parallelFor(chunk.range.lb(), chunk.range.ub()).exec(
						new Loop() {
							LongVbl thrdmaxSize; // local result
							LongVbl thrdClique;
							public void start() {
								thrdClique = (LongVbl) threadLocal(clique); 
								thrdmaxSize = (LongVbl) threadLocal(maxSize); // assigning
								// local count
								// with final
							}

							public void run(long A) {
								
								boolean isClique = true;
								// ((A & (1 << i)) != 0)
								int len = Long.toBinaryString(A).length();
								for (int j = 0; j < len; j++) {
									if ((A & (1 << j)) != 0) {
										long test = A & graph[j];
										// System.out.println(Long.toBinaryString(test)+" "+j);
										if (Long.bitCount(test) != Long
												.bitCount(A)) {
											isClique = false;
											break;
										}
									}
								}
								if (isClique
										&& Long.bitCount(A) > thrdmaxSize.item) {
									thrdmaxSize.item = Long.bitCount(A);
									thrdClique.item=A;

								}

							}
						});
				if(maxSize.item>finalCount){
				finalCount = maxSize.item;
				finalClique=clique.item;
				}
				
			}
			putTuple(new ResultTuple(finalCount, finalClique));

		}
	}

	/**
	 * The Class ChunkTuple. Stores info about the range of the chunk
	 * 
	 * @author Trushank
	 */
	private static class ChunkTuple extends Tuple {

		/** The range. */
		public LongRange range;

		/**
		 * Instantiates a new chunk tuple.
		 */
		public ChunkTuple() {
		}

		/**
		 * Instantiates a new chunk tuple.
		 * 
		 * @param range
		 *            the range
		 */
		public ChunkTuple(LongRange range) {
			this.range = range;
		}
	}

	/**
	 * The Class ResultTuple. Stores result generated by the task nodes
	 */
	private static class ResultTuple extends Tuple {

		public long maxCliqueSize;
		public long clique;

		/**
		 * Instantiates a new result tuple.
		 */
		public ResultTuple() {
		}

		/**
		 * Instantiates a new result tuple.
		 * 
		 * @param maxCliqueSize
		 *            the count
		 */
		public ResultTuple(long maxCliqueSize, long clique) {
			this.maxCliqueSize = maxCliqueSize;
			this.clique = clique;
		}
	}

	/**
	 * The Class InputTuple. Represents the input tuple passed to the worker
	 * tasks
	 */
	private static class InputTuple extends Tuple {

		/** The graph. */
		public long[] graph;

		/** The full. */
		long full;

		/**
		 * Instantiates a new input tuple.
		 */
		public InputTuple() {
		}

		/**
		 * Instantiates a new input tuple.
		 * 
		 * @param graph
		 *            the graph
		 * @param full
		 *            the full
		 */
		public InputTuple(long[] graph, long full) {
			this.graph = graph;
			this.full = full;
		}
	}

	/**
	 * The Class ReduceTask. Reads the result tuples from tuplespace, reduces
	 * them and prints output
	 */
	public static class ReduceTask extends Task {

		/**
		 * Reduce task main program.
		 * 
		 * @param args
		 *            the arguments
		 * @throws Exception
		 *             the exception
		 */
		public void main(String[] args) throws Exception {
			int K = inputTupleCount();
			long maxSize = 0L;
			long clique=0;
			
			for (int i = 0; i < K; ++i) {
				ResultTuple r=(ResultTuple) getTuple(i);
				if (maxSize < r.maxCliqueSize){
					maxSize = r.maxCliqueSize;
				clique = r.clique;
				}
			}
			System.out.printf("%d%n", maxSize);
			System.out.println(clique);
		}
	}

}
